<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <title>Spielhilfe Dungeons, Dice & Danger</title>
  <link rel="stylesheet" href="styles.css">
</head>
<body>
  <h1>üé≤ Spielhilfe Dungeons, Dice & Danger</h1>

  <div class="header-controls">
    <button id="menuButton" class="menu-button">‚ò∞</button>
  </div>

  <!-- Menu Overlay -->
  <div id="menuOverlay" class="menu-overlay">
    <div class="menu-content">
      <div class="menu-header">
        <h3>‚öôÔ∏è Einstellungen & Synchronisation</h3>
        <button id="closeMenu" class="close-button">‚úï</button>
      </div>

      <!-- Hauptfunktionen -->
      <div class="menu-section">
        <h4>üéÆ Spiel-Steuerung</h4>
        <div class="button-row">
          <button id="rollButton" class="menu-action-button primary">üé≤ W√ºrfeln</button>
          <button id="toggleDark" class="menu-action-button">üåô Darkmode</button>
        </div>
      </div>

      <!-- Anzeige-Optionen -->
      <div class="menu-section">
        <h4>üëÅÔ∏è Anzeige-Optionen</h4>
        <div class="toggle-controls">
          <label class="toggle-label">
            <input type="checkbox" id="toggleFifth" checked />
            <span>5. W√ºrfel Kombinationen anzeigen</span>
          </label>
          <label class="toggle-label">
            <input type="checkbox" id="toggleStats" checked />
            <span>Statistiken anzeigen</span>
          </label>
          <label class="toggle-label">
            <input type="checkbox" id="toggleTimer" checked />
            <span>Timer anzeigen</span>
          </label>
        </div>
      </div>

      <!-- W√ºrfel-Modus -->
      <div class="menu-section">
        <h4>üé≤ W√ºrfel-Modus</h4>
        <div class="dice-mode-controls">
          <label class="toggle-label">
            <input type="radio" name="diceMode" id="diceMode-auto" value="auto" checked />
            <span>Automatisch w√ºrfeln (Klick)</span>
          </label>
          <label class="toggle-label">
            <input type="radio" name="diceMode" id="diceMode-manual" value="manual" />
            <span>Manuell einstellen (Tisch-W√ºrfel)</span>
          </label>
        </div>
      </div>

      <!-- Manuelle W√ºrfel-Einstellung (nur wenn manueller Modus) -->
      <div class="menu-section manual-dice-section" id="manualDiceSection" style="display: none;">
        <h4>üéØ W√ºrfel-Werte einstellen</h4>
        <div class="manual-dice-controls">
          <div class="manual-die-control">
            <label>W√ºrfel 1:</label>
            <select id="manualDie-1" onchange="setDiceValue(1, this.value)">
              <option value="1">1</option>
              <option value="2">2</option>
              <option value="3">3</option>
              <option value="4">4</option>
              <option value="5">5</option>
              <option value="6">6</option>
            </select>
          </div>
          <div class="manual-die-control">
            <label>W√ºrfel 2:</label>
            <select id="manualDie-2" onchange="setDiceValue(2, this.value)">
              <option value="1">1</option>
              <option value="2">2</option>
              <option value="3">3</option>
              <option value="4">4</option>
              <option value="5">5</option>
              <option value="6">6</option>
            </select>
          </div>
          <div class="manual-die-control">
            <label>W√ºrfel 3:</label>
            <select id="manualDie-3" onchange="setDiceValue(3, this.value)">
              <option value="1">1</option>
              <option value="2">2</option>
              <option value="3">3</option>
              <option value="4">4</option>
              <option value="5">5</option>
              <option value="6">6</option>
            </select>
          </div>
          <div class="manual-die-control">
            <label>W√ºrfel 4:</label>
            <select id="manualDie-4" onchange="setDiceValue(4, this.value)">
              <option value="1">1</option>
              <option value="2">2</option>
              <option value="3">3</option>
              <option value="4">4</option>
              <option value="5">5</option>
              <option value="6">6</option>
            </select>
          </div>
          <div class="manual-die-control">
            <label>W√ºrfel 5 (schwarz):</label>
            <select id="manualDie-5" onchange="setDiceValue(5, this.value)">
              <option value="1">1</option>
              <option value="2">2</option>
              <option value="3">3</option>
              <option value="4">4</option>
              <option value="5">5</option>
              <option value="6">6</option>
            </select>
          </div>
          <button id="applyManualDice" class="menu-action-button primary">‚úì Werte √ºbernehmen</button>
        </div>
      </div>

      <!-- Timer-Steuerung (nur wenn Timer aktiviert) -->
      <div class="menu-section timer-section" id="timerSection">
        <h4>‚è±Ô∏è Timer-Steuerung</h4>
        <div class="timer-controls-compact">
          <select id="timerSelect" class="compact-select">
            <option value="60">1 Min</option>
            <option value="120">2 Min</option>
            <option value="180">3 Min</option>
            <option value="240">4 Min</option>
            <option value="300">5 Min</option>
          </select>
          <button id="startTimer" class="compact-button timer-button">‚ñ∂Ô∏è Start</button>
          <button id="stopTimer" class="compact-button timer-button" disabled>‚èπÔ∏è Stop</button>
        </div>
      </div>

      <!-- Spieler-Management -->
      <div class="menu-section">
        <h4>üë• Spieler-Management</h4>
        <div class="player-controls">
          <button id="addPlayer" class="menu-action-button success">‚ûï Spieler hinzuf√ºgen</button>
          <button id="resetAllPlayers" class="menu-action-button danger small">üîÑ Alle zur√ºcksetzen</button>
        </div>
        <label class="toggle-label">
          <input type="checkbox" id="togglePlayers" checked />
          <span>Spieler-Dashboards anzeigen</span>
        </label>
      </div>
      <div id="maxPlayersWarning" class="max-players-warning" style="display: none;">
          ‚ö†Ô∏è Maximale Anzahl aktiver Spieler erreicht! Sie k√∂nnen nur lesen, aber nicht aktiv spielen.
      </div>

      <!-- Synchronisation -->
      <div class="menu-section">
        <h4>üîó Ger√§te-Synchronisation</h4>
        <div class="sync-status" id="syncStatus">
          <span class="status-indicator offline" id="statusIndicator"></span>
          <span id="statusText">Offline</span>
        </div>

        <div class="sync-controls">
          <button id="createRoom" class="menu-action-button success">üè† Raum erstellen</button>
          <div class="join-room-row">
            <input type="text" id="roomIdInput" placeholder="Raum-ID" maxlength="6">
            <button id="joinRoom" class="compact-button">üö™ Beitreten</button>
          </div>
        </div>

        <div class="room-info" id="roomInfo" style="display: none;">
          <div class="room-details-compact">
            <div class="room-id-row">
              <strong>Raum:</strong>
              <span id="currentRoomId">-</span>
              <button id="copyRoomId" class="mini-button">üìã</button>
              <span class="participant-count">üë• <span id="participantCount">0</span></span>
            </div>
            <button id="leaveRoom" class="menu-action-button danger small">üö™ Raum verlassen</button>
          </div>
        </div>

        <div class="qr-section" id="qrSection" style="display: none;">
          <div id="qrCode" class="qr-code-compact"></div>
          <p class="qr-info-compact">QR-Code zum Teilen</p>
        </div>
      </div>


      <!-- Debug Info (nur in Development) -->
      <div class="menu-section debug-section" id="debugSection" style="display: none;">
        <h4>üîß Debug</h4>
        <button id="debugInfo" class="menu-action-button secondary small">Debug-Info anzeigen</button>
      </div>
    </div>
  </div>

  <!-- Timer Display (nur wenn Timer aktiviert) -->
  <div class="countdown-container" id="countdownContainer">
    <div class="countdown-display" id="countdownDisplay">--:--</div>
    <div class="timer-status" id="timerStatus">Timer bereit</div>
  </div>

  <!-- Spieler Dashboards -->
  <div class="players-container" id="playersContainer">
    <!-- Spieler werden dynamisch hinzugef√ºgt -->
  </div>

  <div class="dice-row auto-mode" id="diceRow" onclick="handleDiceClick()">
    <div class="scene"><div class="dice" id="d1"></div></div>
    <div class="scene"><div class="dice" id="d2"></div></div>
    <div class="scene"><div class="dice" id="d3"></div></div>
    <div class="scene"><div class="dice" id="d4"></div></div>
    <div class="scene"><div class="dice is-fifth" id="dice5"></div></div>
  </div>

  <div class="dice-mode-info" id="diceModeInfo">
    Klicken Sie auf die W√ºrfel oder den W√ºrfeln-Button zum automatischen W√ºrfeln
  </div>

  <div id="values" style="display:none;"></div>

  <div id="result">
    <div id="stats"></div>
    <div id="list1"></div>
    <div id="list2"></div>
  </div>

  <!-- Include external sync client -->
  <script src="sync-client.js"></script>
  <script>
    let lastValues = [];
    let lastSplits5unique = [];
    let allPossibleSplits4 = [];
    let allPossibleSplits5 = [];

    // Berechne alle m√∂glichen Kombinationen f√ºr Wahrscheinlichkeiten
    function calculateAllPossibleSplits() {
      allPossibleSplits4 = [];
      allPossibleSplits5 = [];

      // Alle Kombinationen f√ºr 4 W√ºrfel
      for (let a = 1; a <= 6; a++) {
        for (let b = 1; b <= 6; b++) {
          for (let c = 1; c <= 6; c++) {
            for (let d = 1; d <= 6; d++) {
              const splits = getSplits([a, b, c, d]);
              allPossibleSplits4.push(...splits.map(s => s.key));
            }
          }
        }
      }

      // Alle Kombinationen f√ºr 5 W√ºrfel (nur die zus√§tzlichen durch W√ºrfel 5)
      for (let a = 1; a <= 6; a++) {
        for (let b = 1; b <= 6; b++) {
          for (let c = 1; c <= 6; c++) {
            for (let d = 1; d <= 6; d++) {
              for (let e = 1; e <= 6; e++) {
                const arr4 = [a, b, c, d];
                const arr5 = [a, b, c, d, e];
                const splits4 = getSplits(arr4);
                const set4 = new Set(splits4.map(s => s.key));
                const splits5all = getSplits(arr5);

                const splits5unique = splits5all.filter(s => {
                  const uses5 = s.idx.pair1.includes(4) || s.idx.pair2.includes(4);
                  return uses5 && !set4.has(s.key);
                });

                allPossibleSplits5.push(...splits5unique.map(s => s.key));
              }
            }
          }
        }
      }
    }

    function gcd(a, b) {
      while (b !== 0) {
        let temp = b;
        b = a % b;
        a = temp;
      }
      return a;
    }

    function simplifyFraction(numerator, denominator) {
      const divisor = gcd(numerator, denominator);
      return {
        num: numerator / divisor,
        den: denominator / divisor
      };
    }

    function calculateProbability(splitKey, allSplits) {
      const count = allSplits.filter(key => key === splitKey).length;
      const total = allSplits.length;
      const fraction = simplifyFraction(count, total);
      const percentage = ((count / total) * 100).toFixed(1);

      return {
        fraction: fraction,
        percentage: percentage,
        count: count,
        total: total
      };
    }

    function createDice(id) {
      const dice = document.getElementById(id);
      const faces = ['front','back','right','left','top','bottom'];
      const pipsMap = {
        1: [['p1']],
        2: [['p2'], ['p3']],
        3: [['p2'], ['p1'], ['p3']],
        4: [['p2'], ['p4'], ['p5'], ['p3']],
        5: [['p2'], ['p4'], ['p1'], ['p5'], ['p3']],
        6: [['p2'], ['p4'], ['p5'], ['p3'], ['p6'], ['p7']]
      };

      for (let i = 0; i < 6; i++) {
        const value = i + 1;
        const div = document.createElement('div');
        div.className = "face " + faces[i];

        pipsMap[value].forEach(clsArr => {
          const pip = document.createElement('div');
          pip.className = 'pip ' + clsArr.join(' ');
          div.appendChild(pip);
        });

        dice.appendChild(div);
      }
      dice.style.transform = "rotateX(0deg) rotateY(0deg) rotateZ(0deg)";
    }
    ['d1','d2','d3','d4','dice5'].forEach(createDice);

    function orientationForFrontValue(v) {
      switch (v) {
        case 1: return { x: 0,   y: 0,   z: 0   };
        case 2: return { x: 0,   y: 180, z: 0   };
        case 3: return { x: 0,   y: -90, z: 0   };
        case 4: return { x: 0,   y: 90,  z: 0   };
        case 5: return { x: -90, y: 0,   z: 0   };
        case 6: return { x: 90,  y: 0,   z: 0   };
        default: return { x: 0, y: 0, z: 0 };
      }
    }

    function extraSpins() {
      const r = () => 360 * Math.floor(Math.random() * 3);
      return { x: r(), y: r(), z: r() };
    }

    function animateDiceToValue(id, value) {
      const el = document.getElementById(id);
      const base = orientationForFrontValue(value);
      const add  = extraSpins();
      el.style.transform = `rotateX(${base.x + add.x}deg) rotateY(${base.y + add.y}deg) rotateZ(${base.z + add.z}deg)`;
    }

    function rollValues(n) {
      return Array.from({length: n}, () => 1 + Math.floor(Math.random()*6));
    }

    function getSplits(arr) {
      const n = arr.length, out = [], seen = new Set();
      for (let i = 0; i < n; i++) {
        for (let j = i + 1; j < n; j++) {
          for (let k = 0; k < n; k++) {
            if (k === i || k === j) continue;
            for (let l = k + 1; l < n; l++) {
              if (l === i || l === j) continue;
              const pair1 = [arr[i], arr[j]], pair2 = [arr[k], arr[l]];
              const p1k = [...pair1].sort((a,b)=>a-b).join('-');
              const p2k = [...pair2].sort((a,b)=>a-b).join('-');
              const key = [p1k, p2k].sort().join('|');
              if (!seen.has(key)) {
                seen.add(key);
                out.push({ pair1, pair2, key, idx: { pair1:[i,j], pair2:[k,l] } });
              }
            }
          }
        }
      }
      return out;
    }

    function formatSplitsWithProbability(splits, allSplits) {
      splits.sort((a, b) => {
        const minA = Math.min(a.pair1[0] + a.pair1[1], a.pair2[0] + a.pair2[1]);
        const minB = Math.min(b.pair1[0] + b.pair1[1], b.pair2[0] + b.pair2[1]);
        return minA - minB;
      });

      let html = '';
      splits.forEach(s => {
        let sum1 = s.pair1[0] + s.pair1[1];
        let sum2 = s.pair2[0] + s.pair2[1];

        let leftPair = s.pair1, rightPair = s.pair2;
        let leftIdx = s.idx.pair1, rightIdx = s.idx.pair2;
        if (sum1 > sum2) {
          [leftPair, rightPair] = [rightPair, leftPair];
          [leftIdx, rightIdx] = [rightIdx, leftIdx];
          [sum1, sum2] = [sum2, sum1];
        }

        // Pr√ºfen ob Pasch vorliegt
        const isPasch1 = leftPair[0] === leftPair[1];
        const isPasch2 = rightPair[0] === rightPair[1];

        const isFifth = idx => idx === 4;
        const renderPair = (pair, idxs, isPasch) =>
          renderMiniDice(pair[0], isFifth(idxs[0]), isPasch) + renderMiniDice(pair[1], isFifth(idxs[1]), isPasch);

        const pair1HTML = renderPair(leftPair, leftIdx, isPasch1);
        const pair2HTML = renderPair(rightPair, rightIdx, isPasch2);

        const probability = calculateProbability(s.key, allSplits);

        html += `
          <div class="pair-line">
            <div class="pair-display">
              ${pair1HTML} ${pair2HTML}
            </div>
            <div class="sum-display">
              ${sum1}, ${sum2}
            </div>
            <div class="probability-display">
              <div class="probability-fraction">${probability.fraction.num}/${probability.fraction.den}</div>
              <div class="probability-percent">${probability.percentage}%</div>
            </div>
          </div>
        `;
      });

      return html;
    }

    function renderMiniDice(value, isFifth = false, isPasch = false) {
      const pipsMap = {
        1: [['p1']],
        2: [['p2'], ['p3']],
        3: [['p2'], ['p1'], ['p3']],
        4: [['p2'], ['p4'], ['p5'], ['p3']],
        5: [['p2'], ['p4'], ['p1'], ['p5'], ['p3']],
        6: [['p2'], ['p4'], ['p5'], ['p3'], ['p6'], ['p7']]
      };

      const pipHTML = pipsMap[value].map(clsArr =>
        `<div class="pip ${clsArr.join(' ')}"></div>`).join('');

      let classes = 'mini-dice';
      if (isFifth) classes += ' is-fifth';
      if (isPasch) classes += ' pasch';

      return `<div class="${classes}">${pipHTML}</div>`;
    }

    // Timer-Funktionalit√§t
    let countdownTimer = null;
    let remainingTime = 0;
    let isTimerRunning = false;

    // Synchronisation Client
    let syncClient = null;

    // Initialisiere Sync Client
    function initSyncClient() {
      // √úberpr√ºfe ob sync-client.js geladen wurde
      if (typeof DDDSyncClient === 'undefined') {
        console.warn('sync-client.js nicht gefunden - lokaler Modus');
        return;
      }

      // F√ºr Netlify Functions wird keine Server URL ben√∂tigt
      // Der Client erkennt automatisch die richtige URL
      syncClient = new DDDSyncClient();

      // Event Callbacks setzen
      syncClient.onStatusChange = updateSyncStatus;
      syncClient.onRoomUpdate = updateRoomInfo;
      syncClient.onDiceReceived = receiveSyncedRoll;
      syncClient.onTimerSync = receiveSyncedTimer;
      syncClient.onError = handleSyncError;
    }

    function updateSyncStatus(status, text) {
      const indicator = document.getElementById('statusIndicator');
      const statusText = document.getElementById('statusText');

      if (indicator && statusText) {
        indicator.className = `status-indicator ${status}`;
        statusText.textContent = text;
      }
    }

    function updateRoomInfo(roomData) {
      if (roomData.roomId) {
        document.getElementById('currentRoomId').textContent = roomData.roomId;
        document.getElementById('participantCount').textContent = roomData.participantCount || 0;
        document.getElementById('roomInfo').style.display = 'block';
        document.getElementById('leaveRoom').style.display = 'inline-block';
        updatePlayerStatus();
      } else {
        document.getElementById('roomInfo').style.display = 'none';
        document.getElementById('leaveRoom').style.display = 'none';
      }
    }

    function receiveSyncedRoll(values) {
      console.log('Received synced roll:', values);
      displayRoll(values);
    }

    function receiveSyncedTimer(timerState) {
      console.log('Received synced timer:', timerState);

      if (timerState.isRunning && !isTimerRunning) {
        // Starte Timer synchronisiert
        remainingTime = timerState.remainingTime;
        isTimerRunning = true;
        document.getElementById('startTimer').disabled = true;
        document.getElementById('stopTimer').disabled = false;

        if (countdownTimer) clearInterval(countdownTimer);
        countdownTimer = setInterval(() => {
          remainingTime--;
          updateCountdownDisplay();

          if (remainingTime <= 0) {
            clearInterval(countdownTimer);
            isTimerRunning = false;
            document.getElementById('startTimer').disabled = false;
            document.getElementById('stopTimer').disabled = true;
          }
        }, 1000);

      } else if (!timerState.isRunning && isTimerRunning) {
        // Stoppe Timer synchronisiert
        stopTimer();
      }
    }

    function handleSyncError(error) {
      console.error('Sync error:', error);
      updateSyncStatus('offline', 'Synchronisationsfehler');
    }

    function createRoom() {
      if (!syncClient) {
        initSyncClient();
        setTimeout(createRoom, 2000);
        return;
      }

      syncClient.createRoom().then(response => {
        console.log('Room created:', response);
      }).catch(error => {
        alert('Raum konnte nicht erstellt werden: ' + error.message);
      });
    }

    function joinRoom() {
      const roomId = document.getElementById('roomIdInput').value.trim();
      if (!roomId || roomId.length !== 6) {
        alert('Bitte geben Sie eine g√ºltige 6-stellige Raum-ID ein.');
        return;
      }

      if (!syncClient) {
        initSyncClient();
        setTimeout(() => joinRoom(), 2000);
        return;
      }

      syncClient.joinRoom(roomId).then(response => {
        console.log('Joined room:', response);
        document.getElementById('roomIdInput').value = '';
      }).catch(error => {
        alert('Raum beitreten fehlgeschlagen: ' + error.message);
      });
    }

    function leaveRoom() {
      if (syncClient) {
        syncClient.leaveRoom();
      }
      document.getElementById('roomInfo').style.display = 'none';
      document.getElementById('qrSection').style.display = 'none';
      removeSyncIndicator();
    }

    function showQRCode(roomId) {
      const qrSection = document.getElementById('qrSection');
      const qrContainer = document.getElementById('qrCode');

      if (typeof QRCodeGenerator !== 'undefined') {
        const joinUrl = QRCodeGenerator.generateJoinURL(roomId);
        QRCodeGenerator.generate(joinUrl, qrContainer);
        qrSection.style.display = 'block';
      } else {
        // Fallback ohne QR-Code Generator
        qrContainer.innerHTML = '<p>QR-Code Generator nicht verf√ºgbar</p>';
        qrSection.style.display = 'block';
      }
    }

    function copyRoomId() {
      const roomId = document.getElementById('currentRoomId').textContent;

      if (typeof ClipboardHelper !== 'undefined') {
        ClipboardHelper.copy(roomId).then(success => {
          const btn = document.getElementById('copyRoomId');
          const oldText = btn.textContent;
          btn.textContent = success ? '‚úì' : '‚úó';
          setTimeout(() => {
            btn.textContent = oldText;
          }, 1000);
        });
      } else {
        // Fallback
        navigator.clipboard.writeText(roomId).then(() => {
          const btn = document.getElementById('copyRoomId');
          const oldText = btn.textContent;
          btn.textContent = '‚úì';
          setTimeout(() => {
            btn.textContent = oldText;
          }, 1000);
        }).catch(() => {
          alert('Kopieren fehlgeschlagen');
        });
      }
    }

    function addSyncIndicator() {
      document.querySelector('.dice-row').classList.add('synced');
    }

    function removeSyncIndicator() {
      document.querySelector('.dice-row').classList.remove('synced');
    }

    function formatTime(seconds) {
      const mins = Math.floor(seconds / 60);
      const secs = seconds % 60;
      return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
    }

    function updateCountdownDisplay() {
      const display = document.getElementById('countdownDisplay');
      const status = document.getElementById('timerStatus');

      display.textContent = formatTime(remainingTime);

      // Farbwechsel je nach verbleibender Zeit
      display.className = 'countdown-display';
      if (remainingTime <= 10 && remainingTime > 0) {
        display.className += ' danger';
      } else if (remainingTime <= 30 && remainingTime > 0) {
        display.className += ' warning';
      }

      if (remainingTime <= 0) {
        display.textContent = '00:00';
        status.textContent = '‚è∞ Zeit abgelaufen!';
        status.className = 'timer-status finished';

        // Timer beenden
        clearInterval(countdownTimer);
        isTimerRunning = false;
        document.getElementById('startTimer').disabled = false;
        document.getElementById('stopTimer').disabled = true;

        // Akustisches Signal (falls Browser es unterst√ºtzt)
        try {
          const audio = new AudioContext();
          const oscillator = audio.createOscillator();
          const gainNode = audio.createGain();

          oscillator.connect(gainNode);
          gainNode.connect(audio.destination);

          oscillator.frequency.value = 800;
          oscillator.type = 'sine';

          gainNode.gain.setValueAtTime(0.3, audio.currentTime);
          gainNode.gain.exponentialRampToValueAtTime(0.01, audio.currentTime + 1);

          oscillator.start(audio.currentTime);
          oscillator.stop(audio.currentTime + 1);
        } catch(e) {
          // Fallback: Browser unterst√ºtzt kein Audio
          console.log('Audio nicht verf√ºgbar');
        }
      }
    }

    function startTimer() {
      const selectedTime = parseInt(document.getElementById('timerSelect').value);
      remainingTime = selectedTime;
      isTimerRunning = true;

      // Synchronisiere Timer falls verbunden
      if (syncClient && syncClient.currentRoomId) {
        syncClient.syncTimer({
          isRunning: true,
          remainingTime: remainingTime,
          duration: selectedTime,
          startTime: Date.now()
        });
      }

      document.getElementById('startTimer').disabled = true;
      document.getElementById('stopTimer').disabled = false;
      document.getElementById('timerStatus').textContent = '‚è≥ Timer gestartet!';
      document.getElementById('timerStatus').className = 'timer-status running';

      updateCountdownDisplay();

      countdownTimer = setInterval(() => {
        remainingTime--;
        updateCountdownDisplay();

        if (remainingTime <= 0) {
          clearInterval(countdownTimer);
        }
      }, 1000);
    }

    function stopTimer() {
      clearInterval(countdownTimer);
      isTimerRunning = false;
      remainingTime = 0;

      // Synchronisiere Timer-Stop falls verbunden
      if (syncClient && syncClient.currentRoomId) {
        syncClient.syncTimer({
          isRunning: false,
          remainingTime: 0,
          duration: 0,
          startTime: null
        });
      }

      document.getElementById('startTimer').disabled = false;
      document.getElementById('stopTimer').disabled = true;
      document.getElementById('countdownDisplay').textContent = '--:--';
      document.getElementById('countdownDisplay').className = 'countdown-display';
      document.getElementById('timerStatus').textContent = 'Timer bereit';
      document.getElementById('timerStatus').className = 'timer-status';
    }

    function displayRoll(values) {
      lastValues = values;
      ['d1','d2','d3','d4','dice5'].forEach((id, idx) => animateDiceToValue(id, values[idx]));

      document.getElementById("values").textContent = "Ergebnisse: " + values.join(", ");
      document.getElementById("values").style.display = "none";

      const arr4 = values.slice(0,4);
      const arr5 = values.slice();
      const splits4 = getSplits(arr4);
      const set4 = new Set(splits4.map(s => s.key));
      const splits5all = getSplits(arr5);

      lastSplits5unique = splits5all.filter(s => {
        const uses5 = s.idx.pair1.includes(4) || s.idx.pair2.includes(4);
        return uses5 && !set4.has(s.key);
      });

      // Statistiken anzeigen (nur wenn aktiviert)
      if (document.getElementById('toggleStats').checked) {
        const totalCombinations4 = 6 ** 4;
        const totalCombinations5 = 6 ** 5;

        document.getElementById("stats").innerHTML = `
          <div class="stats-panel compact">
            <h3>üìä Statistiken</h3>
            <div class="stats-grid">
              <div class="stat-item">
                <span class="stat-value">${splits4.length}</span>
                <div class="stat-label">Gefundene Paare (4 W√ºrfel)</div>
              </div>
              <div class="stat-item">
                <span class="stat-value">${lastSplits5unique.length}</span>
                <div class="stat-label">Zus√§tzliche Paare (5. W√ºrfel)</div>
              </div>
              <div class="stat-item">
                <span class="stat-value">${totalCombinations4}</span>
                <div class="stat-label">M√∂gliche 4-W√ºrfel Kombinationen</div>
              </div>
              <div class="stat-item">
                <span class="stat-value">${totalCombinations5}</span>
                <div class="stat-label">M√∂gliche 5-W√ºrfel Kombinationen</div>
              </div>
            </div>
          </div>
        `;
      } else {
        document.getElementById("stats").innerHTML = '';
      }

      document.getElementById("list1").innerHTML =
        '<div class="section-title">üéØ Liste 1 (nur W√ºrfel 1‚Äì4)</div>' +
        formatSplitsWithProbability(splits4, allPossibleSplits4);

      updateFifthDisplay();
      updateTimerDisplay();
    }

    // Spieler-Management mit verbesserter Synchronisation
    let players = [];
    let nextPlayerId = 1;
    const MAX_ACTIVE_PLAYERS = 4;

    function updatePlayerStatus() {
      const activePlayerCount = players.filter(p => p.isActive).length;
      document.getElementById('activePlayerCount').textContent = activePlayerCount;

      // Warnung anzeigen wenn max. Spieler erreicht und aktueller Benutzer nicht aktiv
      const ownPlayer = players.find(p => p.isOwn);
      const showWarning = activePlayerCount >= MAX_ACTIVE_PLAYERS && (!ownPlayer || !ownPlayer.isActive);
      document.getElementById('maxPlayersWarning').style.display = showWarning ? 'block' : 'none';

      // Add/Remove Button Status aktualisieren
      const addButton = document.getElementById('addPlayer');
      if (activePlayerCount >= MAX_ACTIVE_PLAYERS) {
        addButton.textContent = '‚ûï Spieler hinzuf√ºgen (nur lesend)';
        addButton.title = 'Maximale Anzahl aktiver Spieler erreicht - nur als Zuschauer';
      } else {
        addButton.textContent = '‚ûï Spieler hinzuf√ºgen';
        addButton.title = '';
      }
    }

    function createPlayerDashboard(playerId, playerName = '', sessionId = null, isActive = true) {
      const isOwn = sessionId === syncClient.sessionId;

      const player = {
        id: playerId,
        name: playerName || `Spieler ${playerId}`,
        sessionId: sessionId,
        health: 20,
        blackDice: [false, false, false],
        treasure: {
          heart: [false, false, false],
          torch: [false, false],
          dice: [false, false, false]
        },
        treasureCategories: {
          heart: false,
          torch: false,
          dice: false
        },
        isOwn: isOwn,
        isActive: isActive
      };

      const dashboard = document.createElement('div');
      dashboard.className = `player-dashboard ${isOwn ? 'own' : (isActive ? '' : 'inactive')} ${!isOwn ? 'readonly' : ''}`;
      dashboard.id = `player-${playerId}`;

      const statusText = isOwn ? '(Ihr Spieler)' :
                        isActive ? '(Aktiver Spieler)' : '(Inaktiv - Nur lesend)';

      dashboard.innerHTML = `
        <div class="player-header">
          <input type="text" class="player-name" value="${player.name}"
                 onchange="updatePlayerName(${playerId}, this.value)"
                 placeholder="Spieler Name" ${!isOwn ? 'readonly' : ''}>
          <span class="player-status">${statusText}</span>
          ${isOwn ? `<button class="remove-player" onclick="removePlayer(${playerId})" title="Spieler entfernen">√ó</button>` : ''}
        </div>

        <div class="health-section">
          <div class="section-title-small">‚ù§Ô∏è Lebenspunkte</div>
          <div class="health-bar">
            ${[0, 0, 1, 2, 4, 6, 9, 12, 16, 20].map(value => `
              <div class="health-option">
                <input type="radio" id="health-${playerId}-${value}" name="health-${playerId}"
                       value="${value}" class="health-radio" ${value === 20 ? 'checked' : ''} ${!isOwn ? 'disabled' : ''}
                       onchange="updatePlayerHealth(${playerId}, ${value})">
                <label for="health-${playerId}-${value}" class="health-label">${value}</label>
              </div>
            `).join('')}
            <div class="health-option">
              <input type="radio" id="health-${playerId}-dead" name="health-${playerId}"
                     value="dead" class="health-radio" ${!isOwn ? 'disabled' : ''} onchange="updatePlayerHealth(${playerId}, 'dead')">
              <label for="health-${playerId}-dead" class="health-label dead">üíÄ TOT</label>
            </div>
          </div>
        </div>

        <div class="black-dice-section">
          <div class="section-title-small">üé≤ Schwarze W√ºrfel</div>
          <div class="black-dice-grid">
            ${[0, 1, 2].map(index => `
              <div class="black-die-item">
                <input type="checkbox" class="black-die-checkbox" id="blackdie-${playerId}-${index}" ${!isOwn ? 'disabled' : ''}
                       onchange="updateBlackDie(${playerId}, ${index}, this.checked)">
                <div class="black-die-icon">üéØ</div>
              </div>
            `).join('')}
          </div>
        </div>

        <div class="treasure-section">
          <div class="treasure-category" id="treasure-heart-${playerId}">
            <div class="treasure-category-header">
              <input type="checkbox" class="treasure-category-checkbox" id="category-heart-${playerId}" ${!isOwn ? 'disabled' : ''}
                     onchange="updateTreasureCategory(${playerId}, 'heart', this.checked)">
              <span class="treasure-icon">‚ù§Ô∏è ‚ûï üíé</span>
              <div class="treasure-label">Herz/Diamant</div>
            </div>
            <div class="treasure-checkboxes">
              ${[0, 1, 2].map(index => `
                <input type="checkbox" class="treasure-checkbox heart"
                       id="heart-${playerId}-${index}" disabled
                       onchange="updateTreasure(${playerId}, 'heart', ${index}, this.checked)">
              `).join('')}
            </div>
          </div>

          <div class="treasure-category" id="treasure-torch-${playerId}">
            <div class="treasure-category-header">
              <input type="checkbox" class="treasure-category-checkbox" id="category-torch-${playerId}" ${!isOwn ? 'disabled' : ''}
                     onchange="updateTreasureCategory(${playerId}, 'torch', this.checked)">
              <span class="treasure-icon">üî¶</span>
              <div class="treasure-label">Fackel</div>
            </div>
            <div class="treasure-checkboxes">
              ${[0, 1].map(index => `
                <input type="checkbox" class="treasure-checkbox torch"
                       id="torch-${playerId}-${index}" disabled
                       onchange="updateTreasure(${playerId}, 'torch', ${index}, this.checked)">
              `).join('')}
            </div>
          </div>

          <div class="treasure-category" id="treasure-dice-${playerId}">
            <div class="treasure-category-header">
              <input type="checkbox" class="treasure-category-checkbox" id="category-dice-${playerId}" ${!isOwn ? 'disabled' : ''}
                     onchange="updateTreasureCategory(${playerId}, 'dice', this.checked)">
              <span class="treasure-icon">üé≤</span>
              <div class="treasure-label">W√ºrfel</div>
            </div>
            <div class="treasure-checkboxes">
              ${[0, 1, 2].map(index => `
                <input type="checkbox" class="treasure-checkbox dice"
                       id="dice-${playerId}-${index}" disabled
                       onchange="updateTreasure(${playerId}, 'dice', ${index}, this.checked)">
              `).join('')}
            </div>
          </div>
        </div>
      `;

      players.push(player);
      return dashboard;
    }

    function addOwnPlayer() {
      // Pr√ºfe ob bereits ein eigener Spieler existiert
      if (players.find(p => p.isOwn)) {
        console.log('Own player already exists');
        return;
      }

      const activePlayerCount = players.filter(p => p.isActive).length;
      const canBeActive = activePlayerCount < MAX_ACTIVE_PLAYERS;

      const playersContainer = document.getElementById('playersContainer');
      const dashboard = createPlayerDashboard(nextPlayerId, `Mein Spieler`, syncClient.sessionId, canBeActive);
      playersContainer.appendChild(dashboard);
      nextPlayerId++;

      updatePlayerStatus();
      syncPlayerData();
    }

    function addPlayer() {
      if (!syncClient.currentRoomId) {
        alert('Nicht mit einem Raum verbunden!');
        return;
      }

      const activePlayerCount = players.filter(p => p.isActive).length;
      const canBeActive = activePlayerCount < MAX_ACTIVE_PLAYERS;

      const playersContainer = document.getElementById('playersContainer');
      const dashboard = createPlayerDashboard(nextPlayerId, `Spieler ${nextPlayerId}`, syncClient.sessionId, canBeActive);
      playersContainer.appendChild(dashboard);
      nextPlayerId++;

      updatePlayerStatus();
      syncPlayerData();
    }

    function removePlayer(playerId) {
      const player = players.find(p => p.id === playerId);
      if (!player || !player.isOwn) {
        alert('Sie k√∂nnen nur Ihre eigenen Spieler entfernen!');
        return;
      }

      const dashboard = document.getElementById(`player-${playerId}`);
      if (dashboard) {
        dashboard.remove();
      }

      players = players.filter(p => p.id !== playerId);
      updatePlayerStatus();
      syncPlayerData();
    }

    function updatePlayerName(playerId, newName) {
      const player = players.find(p => p.id === playerId);
      if (player && player.isOwn) {
        player.name = newName;
        syncPlayerData();
      }
    }

    function updatePlayerHealth(playerId, health) {
      const player = players.find(p => p.id === playerId);
      if (player && player.isOwn) {
        player.health = health;
        syncPlayerData();
      }
    }

    function updateBlackDie(playerId, index, checked) {
      const player = players.find(p => p.id === playerId);
      if (player && player.isOwn) {
        player.blackDice[index] = checked;
        syncPlayerData();
      }
    }

    function updateTreasureCategory(playerId, type, checked) {
      const player = players.find(p => p.id === playerId);
      if (!player || !player.isOwn) return;

      if (checked) {
        const selectedCount = Object.values(player.treasureCategories).filter(Boolean).length;
        if (selectedCount >= 2) {
          document.getElementById(`category-${type}-${playerId}`).checked = false;
          alert('Maximal 2 von 3 Schatztruhen-Kategorien k√∂nnen gew√§hlt werden!');
          return;
        }
      }

      player.treasureCategories[type] = checked;

      const maxItems = type === 'torch' ? 1 : 2;
      for (let i = 0; i <= maxItems; i++) {
        const checkbox = document.getElementById(`${type}-${playerId}-${i}`);
        if (checkbox) {
          checkbox.disabled = !checked;
          if (!checked) {
            checkbox.checked = false;
            player.treasure[type][i] = false;
          }
        }
      }

      const categoryDiv = document.getElementById(`treasure-${type}-${playerId}`);
      if (checked) {
        categoryDiv.classList.remove('disabled');
      } else {
        categoryDiv.classList.add('disabled');
      }

      updateTreasureCategoryStates(playerId);
      syncPlayerData();
    }

    function updateTreasureCategoryStates(playerId) {
      const player = players.find(p => p.id === playerId);
      if (!player) return;

      const selectedCount = Object.values(player.treasureCategories).filter(Boolean).length;

      ['heart', 'torch', 'dice'].forEach(type => {
        const categoryCheckbox = document.getElementById(`category-${type}-${playerId}`);
        const categoryDiv = document.getElementById(`treasure-${type}-${playerId}`);

        if (!player.treasureCategories[type] && selectedCount >= 2) {
          categoryCheckbox.disabled = true;
          categoryDiv.classList.add('disabled');
        } else if (!player.treasureCategories[type]) {
          categoryCheckbox.disabled = false;
          categoryDiv.classList.remove('disabled');
        }
      });
    }

    function updateTreasure(playerId, type, index, checked) {
      const player = players.find(p => p.id === playerId);
      if (player && player.isOwn && player.treasureCategories[type]) {
        player.treasure[type][index] = checked;
        syncPlayerData();
      }
    }

    function resetAllPlayers() {
      if (!confirm('Alle Spielerdaten zur√ºcksetzen?')) return;

      // Nur eigene Spieler zur√ºcksetzen
      players.filter(p => p.isOwn).forEach(player => {
        resetPlayerData(player);
        updatePlayerDashboardUI(player);
      });

      syncPlayerData();
    }

    function resetPlayerData(player) {
      player.health = 20;
      player.blackDice = [false, false, false];
      player.treasure = {
        heart: [false, false, false],
        torch: [false, false],
        dice: [false, false, false]
      };
      player.treasureCategories = {
        heart: false,
        torch: false,
        dice: false
      };
    }

    function updatePlayerDashboardUI(player) {
      // Health zur√ºcksetzen
      document.getElementById(`health-${player.id}-20`).checked = true;

      // Schwarze W√ºrfel zur√ºcksetzen
      [0, 1, 2].forEach(index => {
        document.getElementById(`blackdie-${player.id}-${index}`).checked = false;
      });

      // Schatztruhen-Kategorien zur√ºcksetzen
      ['heart', 'torch', 'dice'].forEach(type => {
        const categoryCheckbox = document.getElementById(`category-${type}-${player.id}`);
        const categoryDiv = document.getElementById(`treasure-${type}-${player.id}`);

        categoryCheckbox.checked = false;
        categoryDiv.classList.add('disabled');

        const maxIndex = type === 'torch' ? 1 : 2;
        for (let i = 0; i <= maxIndex; i++) {
          const checkbox = document.getElementById(`${type}-${player.id}-${i}`);
          checkbox.checked = false;
          checkbox.disabled = true;
        }
      });
    }

    function syncPlayerData() {
      if (syncClient && syncClient.currentRoomId) {
        const ownPlayers = players.filter(p => p.isOwn);
        syncClient.syncPlayers(ownPlayers);
      }
    }

    function receivePlayerData(playersData) {
      console.log('Received player data:', playersData);

      playersData.forEach(syncedPlayer => {
        let localPlayer = players.find(p => p.sessionId === syncedPlayer.sessionId);

        if (!localPlayer) {
          // Neuer Spieler von anderem Client
          const activeCount = players.filter(p => p.isActive).length;
          const canBeActive = activeCount < MAX_ACTIVE_PLAYERS;

          const playerId = nextPlayerId++;
          const dashboard = createPlayerDashboard(playerId, syncedPlayer.name, syncedPlayer.sessionId, canBeActive);
          const playersContainer = document.getElementById('playersContainer');
          playersContainer.appendChild(dashboard);

          localPlayer = players[players.length - 1]; // Letzter hinzugef√ºgter
        }

        // Daten aktualisieren (nur wenn es nicht der eigene ist)
        if (localPlayer.sessionId !== syncClient.sessionId) {
          Object.assign(localPlayer, syncedPlayer, {
            id: localPlayer.id,
            isOwn: false,
            isActive: localPlayer.isActive
          });
          updatePlayerDashboardUI(localPlayer);
        }
      });

      updatePlayerStatus();
    }

    function clearAllPlayers() {
      players = [];
      document.getElementById('playersContainer').innerHTML = '';
      nextPlayerId = 1;
      updatePlayerStatus();
    }

    function simulateExistingPlayers() {
      // Simuliere 1-2 bestehende Spieler im Raum
      const existingCount = Math.floor(Math.random() * 2) + 1;

      for (let i = 0; i < existingCount; i++) {
        const playersContainer = document.getElementById('playersContainer');
        const dashboard = createPlayerDashboard(
          nextPlayerId,
          `Spieler ${nextPlayerId}`,
          `session_other_${i}`,
          true
        );
        playersContainer.appendChild(dashboard);
        nextPlayerId++;
      }

      updatePlayerStatus();
    }

    function updatePlayersDisplay() {
      const showPlayers = document.getElementById('togglePlayers').checked;
      const playersContainer = document.getElementById('playersContainer');

      if (showPlayers) {
        playersContainer.classList.remove('hidden');
      } else {
        playersContainer.classList.add('hidden');
      }
    }

    function syncPlayerData() {
      if (syncClient && syncClient.currentRoomId) {
        syncClient.syncPlayers(players);
      }
    }



    function updateTimerDisplay() {
      const showTimer = document.getElementById('toggleTimer').checked;
      const timerContainer = document.getElementById('countdownContainer');
      const timerSection = document.getElementById('timerSection');

      if (showTimer) {
        timerContainer.classList.remove('hidden');
        timerSection.style.display = 'block';
      } else {
        timerContainer.classList.add('hidden');
        timerSection.style.display = 'none';
        // Timer stoppen falls er l√§uft
        if (isTimerRunning) {
          stopTimer();
        }
      }
    }

    function rollAndCalc() {
      const values = rollValues(5);

      // Synchronisiere W√ºrfelwurf falls verbunden
      if (syncClient && syncClient.currentRoomId) {
        syncClient.syncDiceRoll(values);
      }

      displayRoll(values);
    }

    // Toggle-Funktionen f√ºr die neuen Optionen
    function updateStatsDisplay() {
      const showStats = document.getElementById('toggleStats').checked;
      const statsElement = document.getElementById('stats');

      if (showStats && lastValues.length > 0) {
        // Neu berechnen und anzeigen
        displayRoll(lastValues);
      } else {
        statsElement.innerHTML = '';
      }
    }

    // W√ºrfel-Modi
    let currentDiceMode = 'auto';
    let manualDiceValues = [1, 1, 1, 1, 1];

    function handleDiceClick() {
      if (currentDiceMode === 'auto') {
        rollAndCalc();
      }
      // Im manuellen Modus passiert nichts beim Klick
    }

    function updateDiceMode() {
      const autoMode = document.getElementById('diceMode-auto').checked;
      const manualSection = document.getElementById('manualDiceSection');
      const diceRow = document.getElementById('diceRow');
      const modeInfo = document.getElementById('diceModeInfo');

      currentDiceMode = autoMode ? 'auto' : 'manual';

      if (autoMode) {
        manualSection.style.display = 'none';
        diceRow.className = 'dice-row auto-mode';
        modeInfo.textContent = 'Klicken Sie auf die W√ºrfel oder den W√ºrfeln-Button zum automatischen W√ºrfeln';
      } else {
        manualSection.style.display = 'block';
        diceRow.className = 'dice-row manual-mode';
        modeInfo.textContent = 'Stellen Sie die W√ºrfelwerte manuell ein und √ºbernehmen Sie sie';

        // Setze manuelle Werte auf aktuelle W√ºrfelwerte falls vorhanden
        if (lastValues.length > 0) {
          lastValues.forEach((value, index) => {
            document.getElementById(`manualDie-${index + 1}`).value = value;
            manualDiceValues[index] = value;
          });
        }
      }
    }

    function setDiceValue(diceIndex, value) {
      const numValue = parseInt(value);
      manualDiceValues[diceIndex - 1] = numValue;

      // Bestimme die korrekte W√ºrfel-ID
      let diceId;
      if (diceIndex === 5) {
        diceId = 'dice5';
      } else {
        diceId = `d${diceIndex}`;
      }

      // Direkt den W√ºrfel zur entsprechenden Zahl drehen
      animateDiceToValue(diceId, numValue);
    }

    function applyManualDice() {
      // Manuelle Werte als W√ºrfelergebnis setzen
      displayRoll([...manualDiceValues]);

      // Synchronisiere falls verbunden
      if (syncClient && syncClient.currentRoomId) {
        syncClient.syncDiceRoll([...manualDiceValues]);
      }

      // Men√º schlie√üen
      document.getElementById('menuOverlay').classList.remove('show');
    }

    function updateFifthDisplay() {
      const list2 = document.getElementById("list2");
      const showFifth = document.getElementById("toggleFifth").checked;

      if (showFifth && lastSplits5unique.length > 0) {
        list2.innerHTML =
          '<div class="section-title">üé≤ Liste 2 (zus√§tzlich durch W√ºrfel 5)</div>' +
          formatSplitsWithProbability(lastSplits5unique, allPossibleSplits5);
        list2.classList.add("show");
      } else {
        list2.classList.remove("show");
        list2.innerHTML = "";
      }
    }

    // Event Listeners aktualisieren
    document.getElementById("toggleFifth").addEventListener("change", updateFifthDisplay);
    document.getElementById("toggleStats").addEventListener("change", updateStatsDisplay);
    document.getElementById("toggleTimer").addEventListener("change", updateTimerDisplay);
    document.getElementById("togglePlayers").addEventListener("change", updatePlayersDisplay);

    // W√ºrfel-Modus Event Listeners
    document.getElementById("diceMode-auto").addEventListener("change", updateDiceMode);
    document.getElementById("diceMode-manual").addEventListener("change", updateDiceMode);
    document.getElementById("applyManualDice").addEventListener("click", applyManualDice);

    // Spieler-Management Event Listeners
    document.getElementById('addPlayer').addEventListener('click', addPlayer);
    document.getElementById('resetAllPlayers').addEventListener('click', resetAllPlayers);

    // Event Listeners
    document.getElementById('startTimer').addEventListener('click', startTimer);
    document.getElementById('stopTimer').addEventListener('click', stopTimer);

    // Menu Event Listeners
    document.getElementById('menuButton').addEventListener('click', () => {
      document.getElementById('menuOverlay').classList.add('show');
    });

    document.getElementById('closeMenu').addEventListener('click', () => {
      document.getElementById('menuOverlay').classList.remove('show');
    });

    document.getElementById('menuOverlay').addEventListener('click', (e) => {
      if (e.target.id === 'menuOverlay') {
        document.getElementById('menuOverlay').classList.remove('show');
      }
    });

    // W√ºrfeln Button im Men√º
    document.getElementById('rollButton').addEventListener('click', () => {
      rollAndCalc();
      document.getElementById('menuOverlay').classList.remove('show');
    });

    document.getElementById('createRoom').addEventListener('click', () => {
      syncClient.createRoom();
    });
    document.getElementById('joinRoom').addEventListener('click', () => {
      const roomId = document.getElementById('roomIdInput').value.trim();
      if (!roomId) {
        alert('Bitte Raum-ID eingeben');
        return;
      }
      syncClient.joinRoom(roomId);
    });

    document.getElementById('leaveRoom').addEventListener('click', () => {
      syncClient.leaveRoom();
      updateRoomInfo({});
    });
    document.getElementById('copyRoomId').addEventListener('click', copyRoomId);

    // Dark Mode Toggle
    document.getElementById("toggleDark").addEventListener("click", () => {
      document.body.classList.toggle("dark");

      const btn = document.getElementById("toggleDark");
      if (document.body.classList.contains("dark")) {
        btn.textContent = "üåû Lightmode";
      } else {
        btn.textContent = "üåô Darkmode";
      }
    });

    // Debug-Funktionalit√§t (nur in Development)
    if (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1') {
      document.getElementById('debugSection').style.display = 'block';
      document.getElementById('debugInfo').addEventListener('click', () => {
        if (syncClient) {
          console.log('Debug Info:', syncClient.getDebugInfo());
          alert(JSON.stringify(syncClient.getDebugInfo(), null, 2));
        } else {
          alert('Sync Client nicht initialisiert');
        }
      });
    }

    // URL Parameter pr√ºfen f√ºr Auto-Join
    function checkURLParams() {
      if (typeof URLHelper !== 'undefined') {
        const roomParam = URLHelper.getRoomFromURL();
        if (roomParam) {
          document.getElementById('roomIdInput').value = roomParam;
          // Auto-open menu und join
          document.getElementById('menuOverlay').classList.add('show');
          setTimeout(() => {
            joinRoom();
            URLHelper.removeRoomFromURL();
          }, 500);
        }
      } else {
        // Fallback ohne URLHelper
        const urlParams = new URLSearchParams(window.location.search);
        const roomParam = urlParams.get('room');
        if (roomParam) {
          document.getElementById('roomIdInput').value = roomParam;
          document.getElementById('menuOverlay').classList.add('show');
          setTimeout(() => {
            joinRoom();
          }, 500);
        }
      }
    }

    // Initialisierung
    calculateAllPossibleSplits();
    checkURLParams();
    initSyncClient();
    rollAndCalc();
    updatePlayerStatus();
    console.log('DDD Sync Player Management initialized');

  </script>
</body>
</html>
